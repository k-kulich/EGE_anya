def task1():
    # нам нужно перебрать много чисел  --  по факту в егэ лимита в 1000 хватает
    # если нам нужно найти минимум, изначально переменную зададим оооочень большой (здесь миллиард)
    res_min = 10**9  # здесь будем хранить минимальное число, большее 43, которое будет ответом
    for n in range(2, 1000):   # перебираем n, которые будем преобразовывать
        n_bin = oct(n)[2:]  # '0o' - это первые 2 символа всегда, они служебные и не относятся к 
        # двоичной записи числа. [2:] -- "отрежь от строки первые 2 элемента"
        # можно и в цикле, но зачем, если всего 2 шага?
        summ = n_bin.count('1')  # считаем количество всех 1 в числе - это и есть сумма всех цифр
        n_bin += str(summ % 2)  # дописываем в конец остаток от деления суммы на 2    str(1) -> '1'
        summ = n_bin.count('1')  # снова считаем сумму
        n_bin += str(summ % 2)  # снова дописываем
        r = int(n_bin, 8)  # переводим в 10-ичную СС
        if r > 43 and r < res_min:  # если r подходит  под условие, то обновим минмальное значение
            res_min = r
    print(res_min)  # выведем ответ

def task2():
    unique_elements = set()  # вот тута будем хранить уникальные числа
    for n in range(1000):
        n_oct = oct(n)[2:]
        if n % 4 == 0:
            n_oct = '1' + n_oct
        else:
            n_oct += '1'
        r = int(n_oct, 8)
        if 590 < r < 650:  # r > 590 and r < 650
            unique_elements.add(r)  # добавим в множество новое значение - если оно уже там, оно не
            # продублируется
    print(len(unique_elements))  # выведем мощность множества - это и есть кол-во уник ответов


def test():
    unique_elements = set()
    for n in range(1000):
        n_oct = oct(n)[2:]
        if n % 4 != 1:
            n_oct += '1'
        else:
            n_oct = '1' + n_oct
        r = int(n_oct, 8)
        if r > 590 and r < 650:
            unique_elements.add(r)
    print(len(unique_elements))

def task3():
    # На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R 
    # следующим образом:

    # 1. Строится двоичная запись числа N. +
    # 2. Далее эта запись обрабатывается по следующим правилам:
    # а) если число N дает остаток 0 или 1 при делении на 3, то к этой записи справа дописываются 
    # две первые цифры двоичной записи числа N;
    # б) если число N дает остаток 2 при делении на 3, то считается количество нулей в этой 
    # записи, это количество переводится в двоичную запись и дописывается в конец числа.
    #
    # Полученная таким образом запись является двоичной записью искомого числа R.
    # 
    # Например, для исходного числа 12_10 = 1100_2   результатом является число 110011_2 = 51_10,
    # а для исходного числа 5_10 = 101_2 результатом является число 1011_2 = 11_10.
    # 
    # Укажите минимальное число N, для которого искомое число R большее 122. В ответе 
    # запишите это число в десятичной системе счисления.


    # line = '1203932058203'
    # line[start:stop:step]  -- от start (включ) до stop (не включ) с шагом step
    # line[2:5]  -> '039'
    # line[:2]  -> '12'

    min_n = 10 ** 9  # задаем переменную, куда запишем потом ответ
    for n in range(1000):  # перебираем возможные n (обычно хватает до 1000, но если 
                           # что можно увеличить)
        # строим двоичную запись n
        n_bin = bin(n)[2:]  # так мы получаем число в 2ичной СС (аналогично oct - в 8ричную, 
                            # hex - в 16ричную)
                            # n = 10:   bin(n) -> '0b1010'        bin(n)[2:] -> '1010'
        if n % 3 in {0, 1} and len(n_bin) >= 2:  # если остатки по условию И есть хотя бы 2 цифры
            n_bin = n_bin + n_bin[:2]  # дописываем справа первые 2 цифры числа
        if n % 3 == 2:
            count_zero = n_bin.count('0')  # автоматически считает, сколько подстрок в строке
            bin_count = bin(count_zero)[2:]  # переводим в двоичную СС
            n_bin = n_bin + bin_count  # дописываем кол-во нулей в конец числа
        r = int(n_bin, 2)  # переводим из 2ичной в 10ичную (если указать int(n_bin, 8), то из 8ричной
                           # и тд)
        if r > 122:
            min_n = min(n, min_n)  # min автоматически определяет минимальное число
        
    # после цикла нужно напечатать итоговый ответ
    print(min_n)
        

task3()
