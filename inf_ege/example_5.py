def task1():
    # нам нужно перебрать много чисел  --  по факту в егэ лимита в 1000 хватает
    # если нам нужно найти минимум, изначально переменную зададим оооочень большой (здесь миллиард)
    res_min = 10**9  # здесь будем хранить минимальное число, большее 43, которое будет ответом
    for n in range(2, 1000):   # перебираем n, которые будем преобразовывать
        n_bin = oct(n)[2:]  # '0o' - это первые 2 символа всегда, они служебные и не относятся к 
        # двоичной записи числа. [2:] -- "отрежь от строки первые 2 элемента"
        # можно и в цикле, но зачем, если всего 2 шага?
        summ = n_bin.count('1')  # считаем количество всех 1 в числе - это и есть сумма всех цифр
        n_bin += str(summ % 2)  # дописываем в конец остаток от деления суммы на 2    str(1) -> '1'
        summ = n_bin.count('1')  # снова считаем сумму
        n_bin += str(summ % 2)  # снова дописываем
        r = int(n_bin, 8)  # переводим в 10-ичную СС
        if r > 43 and r < res_min:  # если r подходит  под условие, то обновим минмальное значение
            res_min = r
    print(res_min)  # выведем ответ

def task2():
    unique_elements = set()  # вот тута будем хранить уникальные числа
    for n in range(1000):
        n_oct = oct(n)[2:]
        if n % 4 == 0:
            n_oct = '1' + n_oct
        else:
            n_oct += '1'
        r = int(n_oct, 8)
        if 590 < r < 650:  # r > 590 and r < 650
            unique_elements.add(r)  # добавим в множество новое значение - если оно уже там, оно не
            # продублируется
    print(len(unique_elements))  # выведем мощность множества - это и есть кол-во уник ответов


def test():
    unique_elements = set()
    for n in range(1000):
        n_oct = oct(n)[2:]
        if n % 4 != 1:
            n_oct += '1'
        else:
            n_oct = '1' + n_oct
        r = int(n_oct, 8)
        if r > 590 and r < 650:
            unique_elements.add(r)
    print(len(unique_elements))


test()
