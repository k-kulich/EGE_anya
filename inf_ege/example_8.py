import itertools

def task1():
    # Все 4-буквенные слова, в составе которых могут быть буквы Н, Р, Д, О, записаны в 
    # определённом порядке и пронумерованы, начиная с 1. Ниже приведено начало списка.
    # 1. НННН - 0000 - 0
    # 2. НННР - 0001 - 1
    # 3. НННД - 2
    # 4. НННО - 3
    # 5. ННРН - 4
    # ...  
    # Под каким номером в списке идёт слово “ДРОН”?

    # идея в том, что мы работаем с системой счисления, в которой вместо цифр данные буквы.
    # здась: 4 буквы -> сопоставить с 4-ричной СС. НО! надо посмотреть, в каком порядке меняются
    # буквы: Н -> Р -> Д -> О, а значит их можно сопоставить цифрам: Н - 0, Р - 1, Д - 2, О - 3

    # получается, что НННН - это 0000 (0), НННР - это 0001 (1), НННД - это 0002 (2), НННО - это 003 (3),
    # ННРН - это 0010 в 4-ричной (4 в десятичной)

    # просто нумеруем числа системы счисления

    # вариант 1 - решение в лоб
    alph = "НРДО"
    counter = 0  # это номер текущего слова
    for first in alph:
        for second in alph:
            for third in alph:
                for forth in alph:
                    counter += 1
                    if first + second + third + forth == "ДРОН":
                        print(counter)

    # вариант решения 2 - просто заменить на цифры
    number = "2130"  # слову сопоставили циферки
    print(int(number, 4) + 1)  # просто выводим номер нужного числа

    # вариант 3 - itertools
    alph = "НРДО"  # перечисляем все буквы
    letter_count = 4  # скольки буквенные слова нам нужны
    counter = 0  # номер текущего числа

    itertools.permutations(alph, letter_count)  # перебирает все перестановки букв без повторений 
    # (только 1 раз)

    for prod in itertools.product(alph, repeat=letter_count): 
        counter += 1
        # print(''.join(prod))  # prod = ('Н', 'Р', 'Д', 'О')  -> "НРДО"
        if ''.join(prod) == "ДРОН":  
            print(counter)

def task2():
    # Вова составляет 4-буквенные слова из букв С, А, М, О, Р, З, В, И, Т, Е. 
    # Каждая из букв может встречаться в слове ровно один раз или не встречаться вовсе. 
    # Сколько различных слов может составить Вова?

    # дан набор букв - это алфавит (закодированные цифры СС, у нас 10ичная СС)
    # нам нужно с помощью комбинаторных функций перебрать все 4-бкв слова, в которых
    # каждая буква встречается не более 1 раза -- перебираем сочетания (permutations) (бином Ньютона)

    alphabet = 'С, А, М, О, Р, З, В, И, Т, Е'.split(', ')  # так мы получим список букв
    count = 0  # здесь будем хранить количество слов
    for word in itertools.permutations(alphabet, 4):  # перебирает c_n ^ k, где k = 4 (то есть 
                                                      # все 4х букв слова, где никакая буква не повтор)
        count += 1  # увеличиваем счетчик
    print(count)  # печатаем ответ


task2()
